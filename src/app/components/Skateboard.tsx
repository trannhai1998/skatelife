/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useEffect, useMemo, useRef } from 'react';
import { useGLTF, useTexture } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame } from '@react-three/fiber';
import gsap from 'gsap';

type SkateboardProps = {
	deckTextureURLs: string[];
	deckTextureURL: string;
	wheelTextureURLs: string[];
	wheelTextureURL: string;
	truckColor: string;
	boltColor: string;
	pose?: 'upright' | 'side';
	constantWheelSpin?: boolean;
};

type GLTFResult = GLTF & {
	nodes: {
		GripTape: THREE.Mesh;
		Wheel1: THREE.Mesh;
		Wheel2: THREE.Mesh;
		Deck: THREE.Mesh;
		Wheel4: THREE.Mesh;
		Bolts: THREE.Mesh;
		Wheel3: THREE.Mesh;
		Baseplates: THREE.Mesh;
		Truck1: THREE.Mesh;
		Truck2: THREE.Mesh;
	};
	// eslint-disable-next-line @typescript-eslint/no-empty-object-type
	materials: {};
};

export function Skateboard({
	deckTextureURLs,
	deckTextureURL,
	wheelTextureURLs,
	wheelTextureURL,
	truckColor,
	boltColor,
	constantWheelSpin = false,
	pose = 'upright',
	...props
}: SkateboardProps) {
	const wheelRefs = useRef<THREE.Object3D[]>([]); // 4 wheels

	const { nodes } = useGLTF('/skateboard.gltf') as unknown as GLTFResult;

	const wheelTextures = useTexture(wheelTextureURLs);
	wheelTextures.forEach((texture) => {
		texture.flipY = false;
		texture.colorSpace = THREE.SRGBColorSpace;
	});

	const wheelTextureIndex = wheelTextureURLs.findIndex(
		(url) => url === wheelTextureURL,
	);

	const wheelTexture = wheelTextures[wheelTextureIndex] || wheelTextures[0];

	// Find Deck Texture
	const deckTextures = useTexture(deckTextureURLs);
	deckTextures.forEach((texture) => {
		texture.flipY = false;
		texture.colorSpace = THREE.SRGBColorSpace;
	});

	const deckTextureIndex = deckTextureURLs.findIndex(
		(url) => url === deckTextureURL,
	);

	const deckTexture = deckTextures[deckTextureIndex] || deckTextures[0];

	const gripTapeDiffuse = useTexture('/skateboard/griptape-diffuse.webp');
	const gripTapeRoughness = useTexture('/skateboard/griptape-roughness.webp');

	const gripTapeMaterial = useMemo(() => {
		const material = new THREE.MeshStandardMaterial({
			map: gripTapeDiffuse, // background texture
			bumpMap: gripTapeDiffuse,
			bumpScale: 3.5,
			roughness: 0.8,
			color: '#555555',
		});

		return material;
	}, [gripTapeDiffuse]);

	if (gripTapeDiffuse) {
		gripTapeDiffuse.wrapS = THREE.RepeatWrapping;
		gripTapeDiffuse.wrapT = THREE.RepeatWrapping;
		gripTapeDiffuse.repeat.set(9, 9);
		gripTapeDiffuse.needsUpdate = true;

		gripTapeRoughness.wrapS = THREE.RepeatWrapping;
		gripTapeRoughness.wrapT = THREE.RepeatWrapping;
		gripTapeRoughness.repeat.set(9, 9);
		gripTapeRoughness.needsUpdate = true;

		gripTapeRoughness.anisotropy = 8;
	}

	// Bolt Material
	const boltMaterial = useMemo(
		() =>
			new THREE.MeshStandardMaterial({
				color: boltColor,
				metalness: 0.5,
				roughness: 0.3,
			}),
		[boltColor],
	);

	const metalNormal = useTexture('/skateboard/metal-normal.avif');
	metalNormal.wrapS = THREE.RepeatWrapping;
	metalNormal.wrapT = THREE.RepeatWrapping;
	metalNormal.anisotropy = 8;

	metalNormal.repeat.set(8, 8);

	// Truck Material
	const truckMaterial = useMemo(
		() =>
			new THREE.MeshStandardMaterial({
				color: truckColor,
				normalMap: metalNormal,
				normalScale: new THREE.Vector2(0.3, 0.3),
				metalness: 0.5,
				roughness: 0.2,
			}),
		[metalNormal, truckColor],
	);

	const deckMaterial = useMemo(
		() =>
			new THREE.MeshStandardMaterial({
				map: deckTexture,
				roughness: 0.1,
			}),
		[deckTexture],
	);

	// Wheel

	const wheelMaterial = useMemo(
		() =>
			new THREE.MeshStandardMaterial({
				map: wheelTexture,
				roughness: 0.8,
			}),
		[wheelTexture],
	);

	// Add wheel Refs
	const addToWheelRefs = (ref: THREE.Object3D | null) => {
		if (ref && !wheelRefs.current.includes(ref)) {
			wheelRefs.current.push(ref);
		}
	};

	useFrame(() => {
		if (!wheelRefs.current?.length || !constantWheelSpin) return;

		for (const wheel of wheelRefs.current) {
			wheel.rotation.x += 0.2;
		}
	});

	useEffect(() => {
		// ensure wheelRefs is initialized and contains = false
		if (!wheelRefs.current?.length || constantWheelSpin) return;

		for (const wheel of wheelRefs.current) {
			gsap.to(wheel.rotation, {
				x: '+=30',
				duration: 2.5,
				ease: 'circ.out',
			});
		}
	}, [constantWheelSpin, wheelTextureURL]);

	const position = useMemo(
		() =>
			({
				upright: {
					rotation: [0, 0, 0],
					position: [0, 0, 0],
				},
				side: {
					rotation: [0, 0, Math.PI / 2],
					position: [0, 0.295, 0],
				},
			}) as const,
		[],
	);

	return (
		<group
			{...props}
			dispose={null}
			position={position[pose].position}
			rotation={position[pose].rotation}>
			<group name="Scene">
				<mesh
					name="GripTape"
					castShadow
					receiveShadow
					geometry={nodes.GripTape.geometry}
					material={gripTapeMaterial}
					position={[0, 0.286, -0.002]}
				/>
				<mesh
					name="Wheel1"
					castShadow
					receiveShadow
					geometry={nodes.Wheel1.geometry}
					material={wheelMaterial}
					position={[0.238, 0.086, 0.635]}
					ref={addToWheelRefs}
				/>
				<mesh
					name="Wheel2"
					castShadow
					receiveShadow
					geometry={nodes.Wheel2.geometry}
					material={wheelMaterial}
					position={[-0.237, 0.086, 0.635]}
					ref={addToWheelRefs}
				/>
				<mesh
					name="Wheel3"
					castShadow
					receiveShadow
					geometry={nodes.Wheel3.geometry}
					material={wheelMaterial}
					position={[0.237, 0.086, -0.635]}
					rotation={[Math.PI, 0, Math.PI]}
					ref={addToWheelRefs}
				/>
				<mesh
					name="Wheel4"
					castShadow
					receiveShadow
					geometry={nodes.Wheel4.geometry}
					material={wheelMaterial}
					position={[-0.238, 0.086, -0.635]}
					rotation={[Math.PI, 0, Math.PI]}
					ref={addToWheelRefs}
				/>

				<mesh
					name="Deck"
					castShadow
					receiveShadow
					geometry={nodes.Deck.geometry}
					material={deckMaterial}
					position={[0, 0.271, -0.002]}
				/>

				<mesh
					name="Bolts"
					castShadow
					receiveShadow
					geometry={nodes.Bolts.geometry}
					material={boltMaterial}
					position={[0, 0.198, 0]}
					rotation={[Math.PI, 0, Math.PI]}
				/>
				<mesh
					name="Baseplates"
					castShadow
					receiveShadow
					geometry={nodes.Baseplates.geometry}
					material={truckMaterial}
					position={[0, 0.211, 0]}
				/>
				<mesh
					name="Truck1"
					castShadow
					receiveShadow
					geometry={nodes.Truck1.geometry}
					material={truckMaterial}
					position={[0, 0.101, -0.617]}
				/>
				<mesh
					name="Truck2"
					castShadow
					receiveShadow
					geometry={nodes.Truck2.geometry}
					material={truckMaterial}
					position={[0, 0.101, 0.617]}
					rotation={[Math.PI, 0, Math.PI]}
				/>
			</group>
		</group>
	);
}

useGLTF.preload('/skateboard.gltf');
